# 10 день. Циклы, типы данных

## Словарик программиста:

**Термины с лекции:**




**Термины с лабораторки:**


***

	© У нас форма распространения знаний устная!

> Нам нужен общий подход к языкам фон-Неймановского типа.

	@@ На языке СИ нельзя присваивать массивы или структуры!
	Есть лишь константный указатель на память, который должен быть в левой части присваивания.

***Ветвление*** — разбиение на альтернативные ветки.
`Альтернативные — когда другие не рассматриваются в случае успеха одной`

Простейший пример — [[оператор присваивания]].

==***Охраняемая инструкция*** — такая, которая снабжена предикатами.

==Ветвление `IF — FI` — вошло в shell  (? открывающие скобки многозвенного ветвления).

Ветвление выбирает одну из двух альтернативных ветвей.
Выбрать и выполнить ветку — одно из основных назначений ветвления.

#### Обобщённое ветвление

Все предохранители и все предикаты одновременно и независимо вычисляются, т.е. нет никакого приоритета в выполнении.
У них свои наборы регистров и переменных, не влияющие друг на друга.

Чтобы ветвление разветвилось, должна быть хотя бы одна истинная ветка, иначе *авария*.

Но компилятор вряд ли может обнаружить ошибку, поскольку она проявляется лишь в процессе runtime.

	© Клянусь мамой, программа работает! Ставлю печать!

Поэтому ошибка при планировании ветвления лежит на плечах программиста.
Программист должен страдать над ветками ветвления.
Составляя их, он должен думать, чтобы ветвление анализировало предикаты.

#### В чём инновационность идей Дейкстры:

Он утверждал:

	Быть может, программист не ошибся. Среди вычислений предохранителей могут быть одновременно истинны, и может быть выполнена любая ветка: и дешёвая, и дорогая.

`Фактически он допускал недетерминированное ветвление.`

> Неалгоритмическое ветвление, с одной стороны, усложняет сам процесс ветвления.
> Это один из способов сокрытия деталей, подробностей.

	Если отдых, то отправляемся в Сочи, причём неважно, самолётом или на поезде.

> При неалгоритмическом ветвлении ветка выбирается не случайно!
> И не по весу, не по цене!
> ==Случайная ветка не является детерминированной.==
> Недетерминированное программирование облегчает выполнение задач.


Ветвление на 2 ветки выполняется одним предикатом и никогда не отказывает (***двузвенное ветвление***).

	© Язык СИ — это птичий, более лаконичный язык. В нём больше скобочек, значков.

Что в нём плохого: 

- break — показатель американского грубого языка!
в СИ нет встроенного стека!

	© Нужны бойцовские качества! Надо уметь ругать языки — тогда вы выплывете на любом собеседовании!

> Когда попадает к вам язык, необходимо узнать его ***с точки зрения Дейкстры*** ==(ветвлений)==, что в нём роскошного.


#### Algol — Pascal — C
Что в них отличается?

- С/С++ — языки динамического программирования.
- В них 'default' получает управление над программой, когда не срабатывает ни один из 'case`ов'.
- Эта особенность позволяет языкам обходить отказ ветвления, т.е. это прагматичные, практичные языки.

В то же время Pascal — это идеальный язык, непрактичный, считающий все ветвления безотказными.

==case/switch/default?==

default — описывает программу
`Пилот спасается, программа падает, а default берёт всё в свои руки`.

> В безцикловых языках цикл заменяется на рекурсию.

==Цикл/рекурсия — ?==

***Факториал*** — *кумулятивное умножение*, умножение с накоплением! 

==Факториал большего числа вычисляется через факториал меньшего числа, который уже вычислен — вот и пример рекурсии==.

- Цикл — борьба предиката с ...

Цикл содержит условие завершения в форме предиката.

Ветки при выполнении влияют на переменные и немного на предикаты.

Цикл работает до последнего предиката и имеет внутри будто бы обобщённое ветвление.

Обобщённый цикл работает до последнего предиката!

Цикл работает много раз, пока одна ветка выполняется.

> Предохранитель в IF FI обеспечивает более защитное программирование, отказ обнаруживается раньше.


Время в жизни — аналоговое (стрелки), непрерывное, континуальное.
Компьютеризированное время — дискретное. Оно удобно для подсчётов.

Метод мат.индукции применим для доказательства некоторых алгоритмов.

`i++` — дисциплина инкрементации.
Параметр — локализованная переменная цикла.

==Цикл с предусловием, цикл с постусловием.
Повтор тела S, пока предикат p истинный.==

Цикл с предусловием может не работать.
Цикл с постусловием (?)

	do while — постусловие
	while do — предусловие

Pascal — untill not (двойное отрицание, использовалось, чтобы формулировка цикла была точной. При отрицании условия — просто Untill, при согласии — двойное отрицание).

## Типы данных.

==Данные== — сообщения в машинно-читаемом операбельном виде.

1) Тип данных — множество изображений (по-другому — значений, того, что на МТ) (слов на алфавите), для которых определено правило их интерпретации==.......==
2) Тип — это ещё и алгебра — вторая часть определения.

Атрибуты — это отношения
Алгебра — это математическая система.

Атрибуты типа (они же входят в алгебру):

- операции
- функции
- отношения
- константы

Машина может работать со значениями, у которых есть материально-физическая реализация (мы говорим не о МТ).

#### Как задать множество значений?

Например, с помощью таблицы, где представлены типы (или списка).

- Pascal — более императивный язык

Пример списка — перечисление типов.

==Перечислимый тип== удобен человеку и машине (удобно и эффективно реализуем).

==Кэш== — это ассоциативная память (в СИ он есть).

#### Эффективные способы задания типов (их 3):

1. 
2. С помощью задания характеристических функций
`Отрезок — чёткий пример — срабатывает за постоянное время (проверка принадлежности отрезку.`
3. С помощью системы аксиом, определяющих изображение.

	3 аккорда — теорема Боймонджи-Якобини-Миллса.

МТ является хорошим примером аппаратной реализации литерного задания множеств.

Базовый тип — аппаратный тип.
Железо бывает нежелезным(!).
Сейчас оно микропрограммное.

МТ одновременно является и неудачным примером, ибо задание даже простейших алгебраических действий сильно затруднено.

==Первая отечественная== ЭВМ БЭСМ.

	Первый — американский компьютер
	Второй — британский
	Но первый континентальный — отечественный!

Она также представляла собой МТ и была неудобной:
на ней также приходилось моделировать числа вещественного типа.

	Всего было 4 пришествия МТ:
	- Первой МТ была она сама;
	- Второй МТ — первые компьютеры;
	- Третья МТ — бортовые компьютеры;
	- Четвёртая МТ — первое появление микроархитектуры.

>И всё это делали ***умные люди***, с математическим подходом!
>Они знали матанализ!

Нам необходима эффективная практическая вычислимость.
Типы данных возникают чаще, чем железки.
Почему мы это приветствуем?
Это позволяет программировать сразу под конкретные классы задач.

>Целые числа - способ нумерации конечных множеств. Но в них нет смысла. Нужны имена!

## Некструктурные типы данных

### 1. Логический тип (здесь, видимо, гроши)

	- bottom _ | _  это знак неопределённости.
	- Он описывает незаданность значения.

	- SQL читается как Сиквел.

	- Структурированный язык - тот, у которого действует своя теорема Бойма-Джакопини-Миллса.

	- На языках СУБД _ | _ обозначается как NULL

> Если в машинном слове хотя бы одна единица, то истина.


> Алгебру приведём на примере таблицы, свойств и диаграммы
>  (формулы + критика).

## Булевский тип

Ему соответствуют булевские данные.

	Какая алгебра появилась: булевская или логическая?

==Свойства логических операций (их 8):==

1)
2)
3)
4)
5)
6)
7)
8)

## Целый тип

Это арифметический тип.
Он несколько сложнее, но более традиционный.

Из курса алгебры известно, что это множество целых чисел вида 0-+1+-2

Целые числа являются кольцом. 

........

Эффективная вычислимость требует замены бесконечного числа чисел на конечный отрезок (множество), в который войдут числа между MIN MAX.

	Кухонный процессор [-32768; 32767], 0 входит в положительную часть.

Т - перераспределённое значение, депутат.

Унарный минус - взятие противоположного числа.
Есть ещё и бинарный минус. Их надо различать.

> Отношение в целом типе размыкает целый тип и переходит в булевский (введён в C99).
> Раз отношения размыкают логический тип, то они не являются операциями (3/5).

Отношения являются операциями если в результате получается тот же тип данных. А рациональные числа - размыкание целого типа.

## Свойства операций и отношений

Если указано множество и принадлежность элементов, то это условия неразмыкания кольца.

Если X + Y - переполнение, то и результат переполнение.

Отсутствие промежуточных результатов вычислений приводит к проблеме переполнения. Причина - ограниченность значений нарушения законов ассоциативности и дистрибутивности.

Деление - медленная операция.

Алгоритм деления - не алгоритм. В нём есть элемент прикидки, эвристического подбора.
Деление сводится к вычитанию с эвристическим подбором.

