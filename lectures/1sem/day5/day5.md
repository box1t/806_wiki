# 5 день. НАМ, т. Шеннона

## Словарик программиста:

**Термины с лекции:**

***
- `Высокоуровневая модель` — более удобная в использовании модель в сравнении с элементарной за счёт введения абстракции.
- `Абстракция` — смысловая конструкция, описывающая длинные на машинном коде операции.
- `Алгоритм с человеческим лицом` — понятный человеку! 
- `Язык Рефал` — теоретический язык, написанный Турчиным для бортового компьютера "Бурана".
- `Основная алгоритмическая модель` — ***модель Тьюринга***.
- `Инкремент числа` — увеличение числа на 1.
- `Операнд` — аргумент операции; данные, которые обрабатываются командой (a+b, 'a' и 'b' — операнды).
- `Предикат` определяется как функция на множестве отношений {И,Л}.
***
- `Аналоговый` — непрерывный, относящийся к физическим величинам (в сравнении с цифровым).
- `Цифровой` — описанный технически, с помощью цифр.
- `pdp11` — машина, на которой впервые появился язык C.

- [Марков](https://dic.academic.ru/dic.nsf/ruwiki/31771)
- [Турчин](https://dic.academic.ru/dic.nsf/ruwiki/114153)
- [Шеннон](https://dic.academic.ru/dic.nsf/ruwiki/1199802)

***
**Термины с лабораторки:**
- [Обратный код](https://github.com/box1t/Moscow_Aviation_Wikipedia/blob/main/lectures/1sem/day1/Обратный%20код.md)
- [Дополнительный код](https://github.com/box1t/Moscow_Aviation_Wikipedia/blob/main/lectures/1sem/day1/Дополнительный%20код.md)
***

# НАМ

***Алгоритмы Маркова в оригинале называны алгорифмами***.
Они были предложены в 1950г. академиком Андреем Марковым (мл.). 
На их концепции физиком Турчиным основан язык Рефал. 
- Компилятор на *Рефале* был написан за несколько недель (!) Турчиным для бортового компьютера "Бурана".

<details>
<summary>Алгоритм прибавления 1 к десятичному числу:</summary>
<br>

  ![image](https://user-images.githubusercontent.com/113284506/210610272-70e59377-bae5-4173-80be-581889cc9ae3.png)
 
</details>

<details>
<summary>Алгоритм кодирования по Цезарю. Кликни</summary>
<br>

  - Рабочий алфавит — латинский.
  - Принцип — перепись сообщения вперёд на 3 буквы. (А-26 = латинский алфавит)
  - Вспомогательная звёздочка * нужна, поскольку она заменяет букву нужным образом (по Цезарю), но последняя буква не будет схвачена => алфавит не будет съеден.
  
  - © Будем использовать маркер. Тем более, что он будет удалён.
  - © С помощью маркера будем менять буквы, и в конце он удалится.
  
  > Алгоритм может останавливаться явно (стрелкой, костылём) и косвенно, когда посылается сообщение с неприменимой командой.
  
***
  
</details>

***
> Входные сообщения (у Маркова) = входное слово, даже если в сообщении много букв.
- У Маркова нет пробелов (как в понимании Тьюринга).
- Звёздочка — это, по сути, маркер движения.
- В конце алгоритма съедается звёздочка (с костылём), и работа завершается.
- С помощью этого трюка можно решить разные задачи.


> - Достаточно ли одного маркера для сообщения (?) 
> - На Тьюринге более простая ленточная структура, и можно использовать один маркер.
На Маркове нужно несколько маркеров.

***

<details>
<summary>Присоединяющие алгоритмы Маркова:</summary>
<br>

  ![image](https://user-images.githubusercontent.com/113284506/210638684-cc122f08-fe8f-44c5-b3b6-676184d37d9b.png)
 
</details>


> **Высокий уровень НАМ** в сравнении с МТ особенно ярко проявляется в рекурсивных правилах вычисления выражений.

![image](https://user-images.githubusercontent.com/113284506/210638952-40660f07-2766-488c-9ca7-bc20362fb3a8.png)


<details>
<summary>Ещё много примеров алгоритмов:</summary>
<br>

  `Сложение`
  ![image](https://user-images.githubusercontent.com/113284506/210639219-df491aae-543d-4bf0-97ed-80745636c8e3.png)
 
  `Вычитание`
  ![image](https://user-images.githubusercontent.com/113284506/210639278-3769a50c-2e7d-4126-9aee-cde7ac4c0a09.png)

  ![image](https://user-images.githubusercontent.com/113284506/210639298-3607238e-7627-41c5-bce2-87007a6dadef.png)
  
  `Модуль разности`
  
  ![image](https://user-images.githubusercontent.com/113284506/210639621-b0f12bf3-c5e9-4fb5-a6ad-03ef425dba72.png)

  ![image](https://user-images.githubusercontent.com/113284506/210639661-bdf2e5a1-88eb-474b-b171-44ea7c0dfc50.png)

  
  `Вычисление остатка от деления на 5`
  
  ![image](https://user-images.githubusercontent.com/113284506/210639802-bdc6a21b-cae8-4371-b21a-66b4eec67062.png)

  
  `Частное от деления на 5`
  
  ![image](https://user-images.githubusercontent.com/113284506/210639855-c3c17d9a-2072-4471-9249-99fc698da566.png)

  ![image](https://user-images.githubusercontent.com/113284506/210639875-6e3c49a4-06d0-4792-b78d-9702651464a2.png)

  
  `Инкремент двоичного числа (в позиционной СС)`
  
  ![image](https://user-images.githubusercontent.com/113284506/210639927-c6dff188-3586-4014-8b7f-2c89ce61b53f.png)

  `Поразрядная импликация двоичного числа`
  
  ![image](https://user-images.githubusercontent.com/113284506/210639976-bf502efc-fd4b-46b9-97b2-3769423ba1ff.png)

  
  `Проверка числа на нечётность`
  
  ![image](https://user-images.githubusercontent.com/113284506/210640014-4848d3c1-57f2-4496-9eb4-d5c02f8a57e6.png)

  ![image](https://user-images.githubusercontent.com/113284506/210640038-3af5a694-0c0b-4186-b227-2c3af8388dc7.png)

  
  `Умножение двух чисел, заключенных в угловые скобки`
  
  ![image](https://user-images.githubusercontent.com/113284506/210640110-bd0fa758-10b4-4d0c-bad0-b8e33094f123.png)

  
</details>

***

> Радиомикрофон фонит — аналоговый (аналоговый и цифровой - разница ?)
> - `Аналоговый` — непрерывный, относящийся к физическим величинам (в сравнении с цифровым).
> - `Цифровой` — описанный технически, с помощью цифр.


- Марков - элементарная, но `высокоуровневая модель` (абстрактная).
- В ней нет явных состояний, поэтому это **алгоритм с человеческим лицом**
***

Вычислить значение выражения, состоящего из цифр (операнда) (!)
- Цифры хороши тем, что их можно до конца вычислять.

> © Обратимся к нашим воронам на Воробьёвых горах.

- Натуральная С/С не работает с пустыми словами.
- Если нулём считать пустое слово, то всё работает.
- В бедных натуральных с/с (без отрицательных чисел) выдаётся модуль разности (© Алгоритм обладает высокой математической культурой)
- `pdp11` машина, на которой впервые появился язык C

**НАМ - культовая вещь, раз она есть в учебниках разных стран.**

- [Марков](https://dic.academic.ru/dic.nsf/ruwiki/31771) - математик, а [Турчин](https://dic.academic.ru/dic.nsf/ruwiki/114153) - физик.

***
> Марков работает *с цифрами*, как и Тьюринг.
> - Марков не делит многочлены, но по признакам делимости выводит отстатки от деления (нет арифметики).
> - По сути вычитает палочки и оставляет неполные.
> - Число - полином.
> - При делении уголком присутствует *эвристика*.

Если в Маркове пишет лямбду или пробелом — иностранный шпион!

> © Марков - ортогональная альтернативная алгоритмическая схема.

<details>
<summary>Книга "Теория алгорифмов" Маркова:</summary>
<br>
  
- Если описывать в двух словах, то это книга по дискретной математике.
- Я её пролистал. Было тяжко вникать в доказательства `(ну ещё бы)`.
- Сами алгорифмы там описаны не сразу, идёт подводка к ним. Алгоритм нахождения НОД можно найти на 92 странице этого сайта (больше ничего не нашёл для нашего применения). 
Для желающих ознакомиться [есть ссылка](https://djvu.online/file/xmHCSA5hcF0LF)
  
![image](https://user-images.githubusercontent.com/113284506/210280703-43055640-c2b2-43e0-ac86-fea8c972e1f0.png)

 
</details>

> - Напиши диаграмму своей задачи в Маркове 

***Мы решили, что Основная алгоритмическая модель — модель Тьюринга.***

***
## 2.4 Исследование алгоритмической модели Тьюринга
- доказательства этих теорем просто не поместились сюда...
## 2.4.1 Теоремы Шеннона

`Клод Шеннон` — 1956 г.

> Результаты доказательств теорем довольно громоздки.
> - Но они позволили выяснить, ***какой смысл имеют состояния головки машины Тьюринга***.

Вводя вспомогательные буквы, мы можем укоротить МТ.
```yaml
У Шеннона много теорем, даже из физики!
```

`Теорема 2.4.1 (про два состояния)` Первая т. Шеннона

- Для любой МТ `T` с множеством состояний Q можно эффективным образом построить МТ `T'`, 
моделирующую машину Тьюринга и имеющую всего два состояния: a и b.
 
Рабочий алфавит содержит: `r = 3 * (p+1) * (s+1) + p` букв.

- Произведение `(p+1) * (s+1)` — одна из характеристик эффективности алгоритма.
- Алгоритм тем эффективнее, чем меньше значение произведения.
- Из этого следует, что смоделированные машины определяют менее эффективные алгоритмы, чем моделирующая машина Т.
- А ещё эти алгоритмы выполняются за большее число тактов.

Откуда берётся тройка в формуле? 3 буквы: движемся **налево, направо или никуда не движемся**

> Смысл теоремы в том, что если алфавит большой, то можно построить короткое сообщение.
 
`Теорема 2.4.2 (про одну букву)` Вторая т. Шеннона

- Для любой машины Тьюринга `T` можно эффективным образом построить МТ `T''`, 
моделирующую машину `Т` и имеющую однобуквенный алфавит.

> Смысл в том, любой алгоритм может быть записан на очень бедном алфавите.
> - Это себя оправдывает на слабом железе!


- МТ с малым числом состояний не может нормально закончить свою работу.
- Из-за технических искажений возникла **морзянка** — раньше звук передавался с трудом.

> По т. Шеннона использование доп.букв не нужно => когда мы используем их, показываем нежелание разобраться в теореме.
> - Состояния и буквы перетекают друг в друга.

> - © Путаница сразу выдаёт шпиона!

`Когда строим диаграмму, постепенно получаем доказательство.`

> - алгоритм из 2 состояний - самая простая семантика (да или нет?) (да! 2 состояния и 5 букв)
***

## 2.5 Вычислимые функции

Синоним вычислимых функций - алгоритмические функции.

* В матане обычно имеют дело с числовыми функциями.
* Но есть и ***абстрактные*** функции на произвольных множествах.

## 2.5.1 Понятие функции на множестве слов

- `Функцией` называют правило, которое каждому слову исходного алфавита ставит в соответствие единственное результирующее слово,
называемое значением функции.
- `Область определения` - множество исходного алфавита L.
- `Множество значений` - множество всех результирующих слов функции.
- Функция определяет ***отображение*** множества исходного алфавита в результирующий.

![image](https://user-images.githubusercontent.com/113284506/210644632-b9aabe45-6afe-46af-a475-fb04d09b1895.png)


## 2.5.2 Понятие вычислимости (только заголовок)
## 2.5.3 Функции, вычислимые по Тьюрингу

![image](https://user-images.githubusercontent.com/113284506/210643699-8338c3c9-1788-49d3-9ad0-b71460e2df72.png)

- `Функция вычислима по Тьюрингу`, если существует МТ с рабочим алфавитом, обрабатывающим эту функцию.

> Функция ***вычислимая*** лучше обычной, потому что вычислимую можно запрограммировать (т.е. автоматизировать).

С точки зрения математики, алгоритм - вычислимая функция.

- Невычислимые можно построить, нарушая алгоритмические методы.
> Найди примеры невычислимых функций (?)

- Для невычислимых функций невозможно построение алгоритма! 

## 2.5.4 Нормированные вычисления

Функция нормированно вычислимая по Тьюрингу, если вычисляет функцию, и в то же время удовлетворяет условиям:
1) никогда не может остановиться после применения
2) перечисляет значения функции и останавливается (*на правильных словах МТ отказать и остановиться не может!*)

> При нормированных вычислениях головка не должна заходить левее λ.

```yaml
- Выкинь # и ставь пометки.
- Согласно теореме, диез - преступление!
- © 6$!
```

- `Теорема 2.5.4` 
Всякая ВТ-функция является НВТ функцией, причем соответствующая МТ не использует никаких вспомогательных букв.

![image](https://user-images.githubusercontent.com/113284506/210645881-e453509f-4adc-46a5-aea3-ee15e2ac8165.png)

- `Теорема 2.5.5` 
Для любой МТ можно эффективным образом построить машину Тn, которая имеет полубесконечную ленту и моделирует машину Tn.

> Кондовый способ = **надёжный**!
> Ограничение ленты не нарушает общности МТ.
  Внутри ленты раздвигается лента, часть слева с мусором отображается вправо, но вычисления идут на нечётной части (1, 3, 5, 7)
> Т.е. внутрь одной полубесконечной ленты засунули другую.

![image](https://user-images.githubusercontent.com/113284506/210646300-359a95ce-b4b7-4a7c-8fab-4fbb120ffa30.png)


## 2.5.5 Предикаты, вычислимые по Тьюрингу

- `Предикат` определяется как функция на множестве отношений {И,Л}.
В случае n = 1 предикат называют ***свойством***, а если n > 1, то n-арным отношением (бинарным, например).
- Предикаты используются при описании алгоритмов, при этом необходимо, чтобы они сами были ***вычислимыми***.

`Определение 2.5.6`

![image](https://user-images.githubusercontent.com/113284506/210647080-7f5d1d74-8773-40bd-a021-46e47623cefc.png)


