# 12 день. Файлы, блоки

#computer_science

## Словарик программиста (надо знать!):

**Термины с лекции:**


[[Case]]



**Термины с лабораторки:**


***
`© Снег выпал, уже погуляли, надо возвращаться.`

### Типы данных. Продолжение

	- К какому множеству относится литерный тип?
	  Повтори схему описания типов!
	  А если о вещественном типе сказать только, что это float или double, то ничего хорошего можно не ждать!

==Схема: множество значений, изображений, интерпретаций.==


### 3.2.8 Понятие о структурном типе данных

Машина фон-Неймана `скалярная` и наши первоначальные типы — `скалярные`!

- ==Скалярные данные== обрабатываются ***за раз***.
- Но ==Групповые данные== обрабатываются ***по компонентам***.

В групповых данных играют роль ***компоненты***!

==Структурные типы — совокупность компонентов, распадаемых на поля и элементы!

	На экзамене приведи примеры из линейной алгебры + из таблички.
	Но одной таблички недостаточно, нужны как минимум пояснения к ней.
	Ты должен показать хоть какие-то знания, а не зубрёжку!

![](Pasted%20image%2020221130021132.png)

Регулярные структуры означают, что все компоненты однотипны.
Также это значит, что либо вектор (матрица), либо множество индексов является ==декартовым произведением==.

==(?)==(его задают либо постепенно, частично, либо...)

Границы массивов задаются константно [MAX]

> - На Pascal есть тип массив.
> - На СИ — это индексированная переменная.
> - На СИ массив — это константный указатель.
> - Но на СИ нет настоящего файлового типа.

	(?) Можно ли отношение равенства делать на СИ?
 
 > - В СИ тип данных есть, а присваивания нет!

`Можешь также приводить свои примеры критики Pascal на экзамене.`
`Поищи, чего нет, например, в питоне. (?) Каких механик там нет?`

Процессор — ***скалярный***!

==(?)== Разница массивов разных типов данных

Массив литер — строка, при этом набор операций ограничен.

Помимо массивов есть регулярные типы — файлы.


Операция отношения доступна для всех типов ==...==

==Обход массива== — рассмотрение всех компонентов без исключений в определённом порядке по одному разу.

==Этот кусок лучше дополнить==

> Для этого есть циклы. Его параметры (?) подставляем в индекс.
> Цикл бежит по времени (?), а индексы бегут по пространству.

`Это довольно абстрактная штука. Но по крайней мере должно быть понятно, что пространство — это x, y, z. То есть мы работаем с коэфами.`

==(?)== Вложенный цикл for Для матрицы.

Скалярная машина перегоняет по строкам элементы `не за копейку, а за рубль.`

==Двумерный массив== — вложенный цикл.

==Напиши примеры на СИ (стр 177)==

[[Массив]] — абстракция обобщенного кусочка памяти машины фон-Неймана.

	СИ и Pascal — программно-реализованные машины фон-Неймана.

	© На Pascal всё более чинно.
—

### 3.2.10 Понятие о записях

Запись — ***структурный тип.***
Доступ не индексированный, а классифицированный.

Комбинированный — значит, что элементы имеют различные типы.

	(?) Как правило.... А как исключение — комплексное число.

Здесь мы вручную с каждым компонентом записи должны работать.

	© Нельзя решить проблему за раз, спустив курок.
	С ней надо разделываться постепенно.

Компилятор управляет памятью.
Все массивы распределяет компилятор.
(Они статичны), и тут уже распределяет память....
==дополни==
Нельзя сказать, что запись — долгий ...., просто он не автоматический.

> Это компенсируется большой семантической нагрузкой: программист не забудет, что он написал.

`Надо знать различные тонкости из книжек, читать книжки по конкретным языкам программирования, чтобы иметь на вооружении всякие трюки!`

	Тонкости нужны!

> Записи неудобны для регулярной обработки, но они несут в себе смысл, и ты не перепутаешь переменные даже через неделю.

	© Мнемоника нужна сегодня, чтобы не ошибиться, и завтра, чтобы не забыть, что вы написали.

==(?)== Нереляционная структура (описана алгеброй).

- В ***структуре*** иерархия!
- В массиве она неестественная, ненатуральная.

`Дата рождения — субструктура, поля которой более очерчены (чем что?)`

	- Римская система счисления какая? Кардинальная или нет?
	- Позиционная?
	- Натуральная?

[[Case]] — переключатель описываемых типов (***многозвенное ветвление***).

У каждого из этих типов своя алгебра, свои отношения и значения.

	Булевский: все нули (False), хотя бы одна единица (True).
	А по целому? Определяем, дополнительный ли этот код (по первому числу)

Как видим, 4 типа совершенно разной интерпретации.

==(?)== Вариантные записи позволяют обойти типовую безопасность.

	На примере девятки рассмотрим разные типы данных:
	- True — булевский
	- 9 — 9 (Char)
	- 9 — 57 (Код ASCII) (И какой это тип?)
	- 9 — 0,00000+e00 (Вещественный)


### 3.2.11 Понятие о файлах

Файл надо обрабатывать совсем по-другому.
`У нас стоит негласный запрет на обработку файлов через массивы`

	© Самый маленький файл всегда больше самого большого массива.

***Файл*** — обобщённая последовательность (из математики).

- Массив — доступен за постоянное время
- Файл — доступен за линейное время

> Размеры файлов велики, но при этом конечны.
> Файлы надо постепенно прочитывать.

==Обращение к диску содержит 2 действия за линейное время и одно движение за постоянное время.==

> Торможение, движение назад всегда медленнее движения вперёд, потому что назад нельзя двигаться (инерционные законы Ньютона, правила электро-механики).

`Считаем, что файл — мгновенная лента.`

> В методичке сказано, что "файл — массив на диске".
> Это ошибка, ловушка для шпиона!
> Не следует загонять файлы в массивы!

`Допущение таких ошибок показывает безграмотность.`
А ещё файлы потенциально бесконечны.

***Перемотки*** — один из методов обработки **длинных последовательностей** (файлов, иначе говоря).

Мы читаем из файлов переменные/ма......, а не блоки.
Мы на более высоком уровне.
Все компоненты нельзя заносить в аывавы, можно лишь какую-то часть.

Строку текстового файла хранить опасно.
Файл в 1мб не поместится в буфер одной строки.

==Внешние файлы==

Время жизни именованных файлов ***шире*** времени жизни ***программы***.
`Она стирается сразу после использования.`

Именование файла должно сопоставляться и с Unix, и с языком СИ!
Это важно!

	Кто сопоставит имя файла на pascal с Unix?
	Обычно это делает динамическое сопоставление.

[[Динамическое сопоставление]]

Не компилятор!
Это делает [Языковая среда](Языковая%20среда.md) во время ==runtime==!

Файлы медленны в доступе и в работе, зато они долговременны, и хранить их в оперативной памяти дороже.
`Сам прикинь стоимость жёсткого диска и оперативной памяти`.

К тому же, оперативной памяти всё время нужно электричество, чтобы в ней что-то хранилось, а файл может годами лежать на жёстком диске.

#### Временные файлы

Они не имеют глобальных имён.
Используют файл, чтобы писать в массив.

Не зарегистрированы в ОС как долговременные.
Могут вообще даже никогда не быть открытыми.
При этом работают быстрее программы.

	Их имена всё же создаются Unix`ом в виде 'SYSnumber', но это наименование временное.

Файлы:
- внешние и внутренние
- текстовые и нетекстовые

***Текстовые файлы*** — файлы из литер;
это универсальный тип для ввода-вывода данных.

Они сами по себе полезны:
у них есть строки, причём строки переменной длины.

	Не все догадываются, что длина строки может быть нулевой.
	А это одна из тонкостей!

Нетекстовые — это не файлы литер.
Они хранят данные как значения во внутреннем .... 

`Т.е. не как код ASCII, а как код в машинном виде.`

Это данные, снятые с датчиков.
Они не предназначены для прямого восприятия человеком.
Они не для человеческого уха или зрения.
Они предназначены для плеера, или для устройства воспроизведения.

`И правда, двоичный машинный код мы можем понять лишь через представление в устройстве, аппаратную реализацию. `

	При вводе-вывод сканируем код по схеме Горнера за линейное время, и при этом экономим время, но усложняется сам процесс компиляции.

[[Схема Горнера]]

	Треть — процессор, треть — кэш, треть — вещественный тип.

	Как исправлялись бракованные процессоры Intel?
	Патчами в Bios.
	А вот процессоры фирм DEC и IBM не ломались!

***

*Какое отношение всё вышесказанное имеет к массивам?*

Вектор коэффициент - многочлен проще задать в компьютере именно так. Потому сами многочлены не годятся для вычислений математики из-за больших погрешностей.

	Цитата знакомого: © Когда я не был женат, мог себе позволить раскрывать определитель матрицы многочлена 11-степени 3 месяца!

> Степень многочлена может быть от 0 до 10.

`Напечатать многочлен — изящный довес к программе.`

Невыгодно числа хранить в текстовом виде.
А также проблематично вводить и выводить их.

### 3.3 Блочная структура программ

`От структур данных к структурам программ.`

==У нас есть основная конструкция ветвления.==
....
А как нам организовать всё?
Если не будет порядка программ по данным, то всё будет не очень эффективно.

> Ещё в ранних ЯП была введена структура БЛОК.
> Это обособленный фрагмент программы со своим локальным контекстом.

Самый хороший пример локального контекста — цикл For.
Цикл For отрабатывает столько, сколько ему написано.
Эта временная переменная является ==параметром==, и она сразу после завершения цикла становится ненужной.

	Пример с присваиванием:
	x1*y := y1*x — пример на дейкстровском питоне
	------
	Дейкстра-питон хорош тем, что в нём нет загромождения программы лишними переменными.
	------
	Пример на ЯП с обычным присваиванием:
	t:=x
	x:=y
	y:=t
	------
	t нужен здесь только в конце!
	Это переменная для swapping`а значений.
	------

> Внутренние блоки возникают как борьба со сложностью.
> Эти блоки разбивают большой на малые, в которых можно решить более мелкие задачи.

[[Блок]] — составная инструкция ЯП, которая текстуально ограничена (скобками составного оператора / фигурными скобками на СИ).

В нём сначала идёт последовательность локальных описаний, а потом последовательность инструкций (т.е. операторов).

Эта программа, или блок, делает какой-то осмысленный набор задач.

	© Pascal не позволяет демонстрировать программирование на первом семестре нормального курса! (нет блоков)

>Если блок вложен, то основной блок "видит" и может пользоваться вложенными переменными, но своими внутренними переменными он не разрешает пользоваться.

Если программа примитивна (в ней мало букв), то одноимённые (омонимичные) переменные ***экранируются***!

> Приоритет отдаётся локальным переменным над глобальными при конфликте имён.

	(?) В языках с блочной системой с развитым вводом-выводом можно ли обойти экранирование?

	Можно сделать это с помощью двух двоеточий.
	:: (туннелирование сквозь экранирование) (?)

Локальные переменные облегчают работу в крупных программах.
Локализация позволяет сэкономить и разгрузить память.

Пока мы не вошли в блок, переменные не существуют, не объявлены.
Лишь при запуске программы компилятор их объявит.

	У глобальных переменных всё объявлено.

>Каждый блок занимает свои локальные переменные только на время программы.
>Память большей части программы экономится, ибо почти весь блок и почти все переменные не задействованы.

В СИ массив индексируется от нуля.
Массивы обрабатывают вложенный цикл for (?)
©©©
Фактически, цикл — это блок, в который заведена локальная переменная.

	© Pascal очень удобно ругать.. Мальчик для битья..

При выходе из блока память, занятая локальными переменными, освобождается и все хранящиеся на них значения теряются.

> Любые переменные в языке СИ по умолчанию имеют класс памяти auto (есть ещё класс static).

`Чтобы изучить рекурсию, надо изучить блочную структуру`.

![](Pasted%20image%2020221130025204.png)

Оператор присваивания: старая переменная грузится на регистр и прибавляется +1.

`Для рекурсии нужен стек! Вспомни ленты универсальной МТ.`

Формальный параметр - локальная переменная.

	А в каких языках есть блочные структуры?

> Текст в ТеХ описан как блочная структура.
> Вообще структура и иерархия программ заимствована у естественных текстов.

## 3.4. Процедуры и функции

Это более развитые программные единицы относительно блоков.

==Цель разбиения.......==

Процедуры и функции фактически вводят в ЯП новые операторы.
Это средства расширения языка.
Они позволяют построить абстрактные типы данных.

Они более сложны, чем блоки, т.к. постоянно, динамически параметризируются (т.е. в процессе выполнения, а не компиляции).

Подпрограмма предназначена для выполнения спец. функции обращения.

## 3.4.1. Описание и использование

Подпрограмму надо описать перед использованием.
Она состоит из 2 частей: заголовка и тела.
В заголовке помимо имени пишется вид подпрограммы, параметры.

	Параметры перечислены списком, по порядку следования — **позиционно**.

## 3.4.2 Вызов функций и процедур.

- Параметры заголовка — формальные параметры (dummy, пустышки).
Войдя в процедуру, мы начинаем выполнять блок.

==Функции отличаются от процедур явным результатом.==

Функции нужен результат, чтобы дальше участвовать в программе.

Результат функции остаётся на регистре (в регистровом файле).
В языке СИ структурированные функции.

	Приквел хорошего тона: функция не должна менять свои аргументы.

## 3.4.3 Передача параметров

При вызове происходит подстановка на место формальных.
(механизм установки связи между подпрограммой и программой)


## 3.4.3.1 Передача по значению

	© Мы не машина Тьюринга, чтобы всё копировать.

==много текста==
Передача по результату является обратной передаче по значению.

## 3.4.3.2 Передача по результату

Результаты отосланы только когда они получены.

Передача выражений и констант по результату бессмысленна и может быть синтаксически некорректной в строго типизированном языке.

Передача массивов по значению или результату помимо удвоенного расхода память на формальные параметры требует копирования содержимого==......==
+сложностные оценки, оценки памяти.

## 3.4.3.3 Передача по ссылке

==Адрес== — низкоуровневый объект памяти.

- При передаче по ссылке подпрограмме передаётся не значение, а адрес объектов.
- Объект без копирования играет роль временного формального параметра.
Работая через ссылку, мы меняем оригинальные значения (?)
Передача по ссылке динамическая.

***Плюсы***: выигрыш по времени и по памяти.

## 3.4.3.4 Передача по имени

..........
